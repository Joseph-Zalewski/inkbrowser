Most of the files in this repo can be safely ignored!
The only ones that matter as far as code goes are:
sdbrowser/__init__.py
sdbrowser/templates/client.html

In addition, sdbrowser/templates/schema1.json is a readable example of the internal schema format (only need to know if you are creating schema diagrams.)

In __init__.py:
Only the client() and query() functions matter now. The rest is left over from testing and I will eventually delete it. __init__.py is effectively finished.

In client.html:
This file is in more of a state of flux. Not everything is exactly as depicted in the architecture diagram (yet).

Things that can be expected to remain static:
The View class. The GraphView subclass illustrates the conventional boilerplate for (old-style) Javascript subclass creation.

Implementing a new View subclass:
The constructor must take "collection" as its first argument. Then it can have additional arguments (e.g. DOMNode). If it is supposed to respond to messages from other views, this must be done by implementing the processNotify() function (this has a single parameter expecting a Javascript Object); to
pass information *to* the other views, you do something like (...create message object M...); for(var v of collection){v.processNotify(M)};

Standard fields to be used in messages:
text - for arbitrary text.
query - for SPARQL queries that the recipient may run. Should not contain a LIMIT clause, and should stay well-formed if ' LIMIT n' is appended.
limit - stores a limit value for the query in query.
endpoint - stores a URL to a SPARQL endpoint.

Every View object automatically has a unique integer identifier (called identifier). To pass a message directly to just one view from anywhere (such as a DOM event handler), use the global function trigger(identifier, msg).

NOTE: InkBrowser's existing code uses old-style plain Javascript subclasses, not ECMAScript 2015 classes, etc. I do not make any guarantees about compatibility with new Javascript features other than guarantees they themselves make. The basic pattern for making a subclass of View, the old-fashioned way, is the following (all text in <<<>>> is placeholder text):

function <<<MyView>>>(collection, <<<additional arguments>>>){
			View.call(this, collection);
			[[[for each additional argument:]]]
			this.<<<argument>>> = <<<argument>>>;
		}
		
		<<<MyView>>>.prototype = Object.create(View.prototype);
		
		Object.defineProperty(<<<MyView>>>.prototype, 'constructor', {value: <<<MyView>>>, enumerable: false, writable: true,});
		
		[[[for each new method:]]]
		Object.defineProperty(<<<MyView>>>.prototype, '<<<methodName>>>', {value: function(<<<method arguments>>>)
		{	
			<<<method code>>>
		}});
		
		[[[for each method override:]]]
		<<<MyView>>>.prototype.<<<methodName>>> = function(<<<arguments>>>)
			{<<<new code>>>};
		
		
		
		
		
		
		
		
