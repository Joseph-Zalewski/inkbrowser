Here is a basic overview to try to extract classes from; rather than describing the use case, it will describe the architecture. Actually, use case first: the user is always someone who wants to query a sparql endpoint, containing some linked data file in RDF format (LDF). From the sdbrowser's point of view, this can be an arbitrary LDF, it need not even be an owl file. User actions: turn on web browser, navigate to ksu daselab domain, connect to server running sdbrowser by visiting its root url. This is the only url the user ever needs his browser to actually display as as HTML page; all other points of access on the server will be reached by AJAX requests. The user enters the URL of a sparql endpoint hosting the LDF he wants. Optionally he also enters the URL of its schema diagram spec. The schema diagram, either good-looking or bad-looking, appears on the page before him. It is clickable. When he clicks on a node, somehow the browser displays a whole bunch of nodes from the LDF which have that diagram node as class (or their rdf:type). It actually shows a whole bunch of triples starting with those nodes. This seems less than awesome to me; like you should get a list of the objects first, and be able to select them to see their triples, but whatever. And that's it. That's what it does.

Nouns: sparql endpoint, LDF, browser, point of view (irrelevant), owl file (irrelevant), web browser, domain, server, url, ajax request, schema diagram spec, schema diagram, page, node (in the diagram), bunch, node (from LDF), class (or rdf:type), triple, list.

Now, how is each of the above actions implemented, as far as you can guess? first thing it's involved in: connect to server running sdbrowser. There must be a static externally visible way to do this, thus a single entry-point url which is part of the contract and will never change. Perhaps "/main". I said this is the only page it need ever display, but that's limiting - it should be open for displaying more pages potentially, with extension of the code. Consider how a new page would be added, and if there is any need to change methods when you do so (OCP). Additional AJAX targets also need to be an option. Entering a URL: this will be an event-driven action: there will be a submit button which invokes a javascript function, which sends an AJAX request. The response is in some format, perhaps XML, and the javascript then creates the schema diagram from that. Displaying: This will be mxGraph invocations. Size will need to be autoscaled to the div. Further growth needs to be left available for size handling and so on. Clickable: mxGraph mxEvent.CLICK listener, which uses the cell property of the click event to identify its target. Display triples: the program should have the triples in some form, but the way they're output is specific. Simply dumping them in a DOM element might be okay. Problem: creating the schema diagram without the spec. There's a logic gate. Using the existing algorithm should suffice, the problem is where in the flow of execution the paths diverge. Is there one function which displays a diagram with a spec, which may or may not be generated? Or two functions, one with spec and one without?

**Approach**: Make a big-ass class diagram. Whenever extension needs to be a possibility, add symptomatic subclasses. Note what constraints on methods are required by LSP when you do this; reorganize as necessary. Where to start? What class does the user actually interact with? In the real world, the Web Browser. But that's the real web browser, not an instance of my Javascript class. Still, the class can be used to represent the user's interface... in reality, mxGraph constrains you here. The user interacts with the mxGraph components & event dispatch happens. The Web Browser/UI class encapsulates all this, and the mxGraph version of it is just a subclass! It naturally looks like a Controller in an MVC architecture. Does the user have to recompile if the UI changes? Reasonable assumption, if recompilation is defined as the enemy. First LSP instance: what UI methods are there that the user calls? All its actual methods are implicit; it merely maintains a component which handles events. By implicit, I mean, the inaggregated complex must call them; it must be an event handler, or automatic event generator, or whatever. It could be a bot designed to use the visual browser - don't know why you would, but it could. So, as a fully abstract class, UI satisfies the LSP automatically? Well, no - it has connections to other things. The UI has views that are dependency-inverted on it. By default, the diagram view is one of these, and so is the list view. My problem is this: are the user-implicit methods things that refer to features of a view, such as "clicked on a class node of the diagram view event handler"? I don't see how they could not be. These are methods of the view. But subclass UI's need to be able to define behavior for new kinds of views. Something seems off about this situation, but does it violate a principle? First, in detail, how does mxUI work? It inherits two member fields from UI: a diagram view and a list view. It maintains mxGraph representations of them. This is a complicated matter which requires separate lower-level modeling. It runs the mxGraph/Javascript event handler, and overrides methods in it to call the user-action implicit methods inherited from UI, which it also overrides to modify the view objects. This is unnecessarily complex, isn't it? Then the mxGraph objects have to query the views to determine how to update. The price to pay for being independent of mxGraph - is that really so important? SRP-what is a reason to change? Is a reason to spawn a subclass a reason to change? Change means recompilation. So no. So, how important is independence of mxGraph? Maybe? Would MVP be better? No! We need a centralized controller. Why? Keep in mind- what happens if the view class changes? It shouldn't, but what if it does? This is what SRP is concerned with. Then all subclasses of UI would have to recompile, since they all use details of different Views! They also depend on UI, of course. Subclasses should only depend on their superclass, if I interpret SRP correctly. So everything about the generic view that a UI might use must be captured by the abstract UI class. What about when a subclass of View changes? Any sub-UI using that View would have to change. Clearly views are tightly coupled to implementations. Is MVP inevitable? Suppose you eliminate centralized UI, and each view has its own implicit user-interaction methods. Each concrete view then has its own event handler. I just can't imagine this in enough depth. View cannot, as the diagram stands, be dependency-inverted on UI. UI does not capture in enough depth what a view might do. Well, UI could simply require of View an interface with a "receiveMessage(m)" function, and subclasses of UI could then specify a message, and a corresponding subclass of view the ability to process that message syntax. That is "required" by DIP. However, there is still coupling! The shared contract of message syntax creates a reason to change. So, reify that contract. Doesn't help. The new message class has all the same issues as the existing classes. Rather, a View-UI pair class seems to be needed, in order to encapsulate all the coupling that occurs. In summary, independence of mxGraph seems to be too ambitious for now. I think I'll have to make a prototype before it's clear how to do this part.

--Back to reality: we don't need to worry about replacing mxGraph. It's kind of rough, but it works. What changes *are* potentially going to happen to the browser in the future, that it needs to be prepared for? Specifically, how does this affect how the return values from AJAX queries are used? Direct method: pass the display DOM element as a parameter to the AJAXQuery function, and from there incorporate it into the onreadystatechange function. When the query returns, call whatever method the display element has to display the results. This could cause asynchronicity chaos. However, it allows arbitrary types of handlers of query results. Future development - obvious: eliminate asynchronicity chaos. Namely, give the query a lock on the DOM element. It seems a displayor must know what query it is processing.