<!DOCTYPE html>
<html>
<title>Sdbrowser Client</title>
<!--This html contains the main client code for sdbrowser. It can:-->
<!--To Do:
	JSON decode - X?
	Add listeners - X
	Host this page from Flask - X
	Send queries to Python server - X
	Create View class - X
	Create graph view - X
	Display query output - X
	Encapsulate functions - X
	Set up message bus - X
	Encapsulate mxGraph imports
	Preliminary message format - X
	Create triple list view
	Create object list view - X
	Fix style on the tree view output
	Access hyperlinks in query output??
	Make paths to mxGraph source code platform-independent
	CoModIDE translator
	Arrow Type?
	To Do on Flask End:
	Host a JSON file??
-->
<head>
	<!-- Names ending in names of View subclassses, e.g. ulTreeView, should be reserved, as CSS class names. Page elements with class xxxYYYView should only be used in HTML generated by class YYYView or intended to interact with it. -->
	<style>
		.ulTreeView {
			list-style-type: none;
		}
		.plusTreeView{
			cursor: pointer;
		}
		.plusTreeView::before{
			content:"+";
		}
		.minusTreeView::before{
			content:"-";
		}
		.nested{
			display: none;
		}
		.active{
			display: block;
		}
	</style>
	
	
	<script type="text/javascript">
		mxBasePath = '/static/mxgraph/javascript/src';
	</script>
	
	<script type="text/javascript">
		JSONtestinput = '{ 	"Boxes":[ 		{"Id":"Source", 		"XOffset":100, 		"YOffset":100, 		"XSize":70, 		"YSize":30, 		"FillColorHex":"#ffffff", 		"TextColorHex":"#ff0000", 		"Label":"Source",    "Query":"PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?X WHERE { <http://dbpedia.org/resource/Asturias> rdfs:label ?X }", 		"Limit":10, 		"Endpoint":"http://dbpedia.org/sparql" 		}, 		 		{"Id":"Sink", 		"XOffset":200, 		"YOffset":300, 		"XSize":70, 		"YSize":30, 		"FillColorHex":"#ef99ef", 		"TextColorHex":"#ff0000", 		"Label":"Sink"} 	], 	"Arrows":[ 		{"Id":"Primary", 		"LabelX":200, 		"LabelY":200, 		"Label":"Primary", 		"ArrowType":"Hollow", 		"Source":"Source", 		"Target":"Sink", 		"Waypoints":[ 				[200,200], 				[220,200] 			] 		}, 		 		{"Id":"Segundo", 		"LabelX":200, 		"LabelY":200, 		"Label":"Secondary", 		"ArrowType":"Solid", 		"Source":"Source", 		"Target":"Sink", 		"Waypoints":[ 				[400,200], 				[20,500], 				[30,750] 			], 		"Query":"PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?X WHERE { <http://dbpedia.org/resource/Asturias> rdfs:label ?X }", 		"Limit":10, 		"Endpoint":"http://dbpedia.org/sparql" 		} 	], 	"Mode":"DEFAULT", "CanvasX":500, "CanvasY":500 }';
	</script>
	
	<script type="text/javascript" src={{url_for('static', filename='mxgraph/javascript/mxClient.js')}}></script>
	
	<script type="text/javascript">
		//viewArray is global. See 'trigger' below.
		var viewArray = [];
		//generates unique identifiers for view objects
		var currentIdentifier = 0;
		function nextIdentifier(){
			currentIdentifier = currentIdentifier + 1;
			return currentIdentifier;
		}
	
		////Class declarations
		//View class. Represents any independent part of the user interface. Since this is Javascript, subclasses can take arbitrary additional constructor parameters containing information such as the DOM node or DOM nodes they will use to display themselves. However, View has one distinguished parameter, collection, which takes a collection of Views. Subclasses can send messages to other views in this collection by calling their processNotify method. This class should be considered abstract and never instantiated except in the constructor of a subclass.
		function View(collection){
			this.collection = collection;
			collection.push(this);
			this.identifier = nextIdentifier();
		}
		View.prototype.processNotify = function(){};
		//end View class
		
		//GraphView subclass.
		function GraphView(collection, DOMNode){
			View.call(this, collection);
			this.DOMNode = DOMNode;
			//holds identifiers of Views that receive data from this one
			this.recipients = [];
		}
		GraphView.prototype = Object.create(View.prototype);
		Object.defineProperty(GraphView.prototype, 'constructor', {value: GraphView, enumerable: false, writable: true,});
		Object.defineProperty(GraphView.prototype, 'JSONToGraph', {value: 
		//Contract: Parameters: String JSONString.
		//Constructs the mxGraph encoded by JSONString, if there is one, displaying it in the DOM element this.DOMNode.
		function(JSONString)
		{	
			var pageElement = this.DOMNode;
			var schema = JSON.parse(JSONString);
			if (!mxClient.isBrowserSupported())
			{
				mxUtils.error('Browser is not supported!', 200, false);
			}
			else{
				mxEvent.disableContextMenu(pageElement);
				var diagram = new mxGraph(pageElement);
				var parent = diagram.getDefaultParent();
				var nodes = {};
				var edges = {};
				diagram.getModel().beginUpdate();
				try{
					for(var b of schema.Boxes){
						nodes[b.Id] = diagram.insertVertex(parent, null, b.Label,b.XOffset,b.YOffset,b.XSize,b.YSize, 'fontColor='+b.TextColorHex+';fillColor='+b.FillColorHex+';'+b.AdditionalMxStyle);
					}
					
					for(var e of schema.Arrows){
						//create edgestyle for this edge
						mxEdgeStyle['sd'+e.Id] = this.constructEdgestyle(e);
						mxStyleRegistry.putValue('sd'+e.Id, mxEdgeStyle['sd'+e.Id]);
						//mxUtils.error(mxStyleRegistry.getValue('sd'+e.Id), 200, false);
						//insert the edge
						edges[e.Id] = diagram.insertEdge(parent, null, e.Label, nodes[e.Source], nodes[e.Target], 'edgeStyle=sd'+e.Id+';'+e.AdditionalMxStyle);
					}
					var collection = this.collection;
					pageElement.onclick = function(){diagram.fireEvent(new mxEventObject('click'));};
					diagram.addListener(mxEvent.CLICK, function(sender, evt)
					{
						alert("caught fired event");
						var e = evt.getProperty('event');
						var cell = evt.getProperty('cell');
						if(cell != null){
							for(b of schema.Boxes){
								if(nodes[b.Id] == cell){
								var q = b.Query + ' LIMIT ' + b.Limit;
								var box = b;
									AJAXQuery(q, box.Endpoint,
										function(str){
											var msg = {text: str, query: box.Query, limit: box.Limit, endpoint: box.Endpoint};
											for(var V of collection){
												V.processNotify(msg);
											}
											});
								}
							}
							for(e of schema.Arrows){
								if(edges[e.Id] == cell){
								var q = e.Query + ' LIMIT ' + e.Limit;
								var edge = e;
									AJAXQuery(q, edge.Endpoint,
										function(str){
											var msg = {text: str, query: edge.Query, limit: edge.Limit, endpoint: edge.Endpoint};
											for(var V of collection){
												V.processNotify(msg);
											}
											});
								}
							}
						}
					});
				}
				catch(err){
					errorDiv.innerHTML = err.toString();
				}
				finally{
					diagram.getModel().endUpdate();
				}
			}
		}});
		Object.defineProperty(GraphView.prototype, 'constructEdgestyle', {value:
		//Contract: e is an Arrow object extracted, e.g., from a parsed internal JSON representation. Returns an mxEdgestyle which encodes the routing information for e, based on e.Waypoints, if that field is defined. Otherwise returns the default mxGraph elbow style.
		function(e)
		{	
			var style;
			if(e.Waypoints){
				style = function(state,source,target,points,result){
					for(var pt of e.Waypoints){
						result.push(new mxPoint(pt[0],pt[1]));
					}
				}
			}else{
				style = mxEdgeStyle.ElbowConnector;
			}
			return style;
		}});
		//end GraphView subclass
		
		//PlainTextView subclass.
		function PlainTextView(collection, DOMNode){
			View.call(this, collection);
			this.DOMNode = DOMNode;
		}
		PlainTextView.prototype = Object.create(View.prototype);
		Object.defineProperty(PlainTextView.prototype, 'constructor', {value: PlainTextView, enumerable: false, writable: true,});
		PlainTextView.prototype.processNotify = function(msg)
			{this.DOMNode.innerHTML = msg.text;};
		
		
		//end PlainTextView subclass
		
		//ListView subclass
		//displays a list of clickable items
		function ListView(collection, DOMNode){
			View.call(this, collection);
			this.DOMNode = DOMNode;
			this.query = '';
			this.limit = 10;
			this.endpoint = '';
			this.DOMNode.innerHTML = '<div></div><button>Load More Results</button>';
		}
		
		ListView.prototype = Object.create(View.prototype);
		
		Object.defineProperty(ListView.prototype, 'constructor', {value: ListView, enumerable: false, writable: true,});
		
		Object.defineProperty(ListView.prototype, 'processJSONResults', {value: function(str)
		{	
			var div = this.DOMNode.getElementsByTagName("div")[0];
			try{
				input = JSON.parse(str);
				div.innerHTML ='<ul>';
				for(var result of input.results.bindings){
					div.innerHTML = div.innerHTML + '<li>' + result.X.value + '</li>';
				}
				div.innerHTML = div.innerHTML + '</ul>';
			}
			catch{
				div.innerHTML = '<ul><li>Invalid or Missing Query Results Received!</li></ul>';
			}
		}});
		
		//Needs a query, for a single variable X. ListView will use the query to load more results if needed.
		//By default ListView assumes any text passed to it is a text representation
		//of JSON SPARQL query results for a query with a single variable X, and extract results.bindings.X.value
		//fields from it.
		ListView.prototype.processNotify = function(msg)
			{
				if(msg.text != undefined){
					this.processJSONResults(msg.text);
				}
				//if the message has no text, then the ListView assumes it is supposed to run a new query.
				else{
					var thisref = this;
					AJAXQuery(msg.query + ' LIMIT ' + msg.limit, msg.endpoint, function(str){
						thisref.processJSONResults(str);
					});
				}
				this.query = msg.query;
				this.limit = msg.limit;
				this.endpoint = msg.endpoint;
				var thisref = this;
				var tr = function(){
					trigger(thisref.identifier, {query:thisref.query, endpoint:thisref.endpoint, limit:(2*thisref.limit)});
				};
				this.DOMNode.getElementsByTagName('button')[0].onclick = tr;
			};
			
			
		//TreeView class
		//root is some object, getChildren(node) is some function which takes an object and returns its children as an array; together these specify an abstract tree. It is the instantiator's responsibility to ensure this tree is not infinite. The TreeView displays this tree as an HTML tree. display() is some function that takes nodes of the abstract tree and converts them into strings to display.
		function TreeView(collection, DOMNode, root, getChildren, display, action){
			View.call(this, collection);
			this.root = root;
			this.getChildren = getChildren;
			this.DOMNode = DOMNode;
			this.display = display;
			this.action = action;
			this.setup(this.DOMNode, this.root, this.action);
		}
		
		TreeView.prototype = Object.create(View.prototype);
		
		Object.defineProperty(TreeView.prototype, 'constructor', {value: TreeView, enumerable: false, writable: true,});
		
		//this method creates the TreeView's tree as HTML inside DOMNode and adds appropriate listeners to it.
		Object.defineProperty(TreeView.prototype, 'setup', {value: function(DOMNode, root, action){
			DOMNode.innerHTML = this.expand(root, true);
			var expanders = DOMNode.getElementsByClassName("plusTreeView");
			for (var ex of expanders){
				ex.addEventListener("click", function(){
					this.parentElement.querySelector(".nested").classList.toggle("active");
					this.classList.toggle("minusTreeView");
				});
				ex.addEventListener("dblclick", function(){
					action(this);
				});
			}
		}
		});
		//this method takes an abstract tree node 'node' and returns the subtree rooted at 'node', in HTML form.
		Object.defineProperty(TreeView.prototype, 'expand', {value: function(node, isRoot)
		{	
			var children = this.getChildren(node);
			var ret;
			if (children.length != 0){
				ret = '<span class=\"plusTreeView\">' + this.display(node) + '</span>';
				ret = ret + '<ul class=\"ulTreeView nested\">';
				for(var child of children){
					ret = ret + '<li>'+this.expand(child, false)+'</li>';
				}
				ret = ret + '</ul>';
			}else{
				ret = '<span>' + this.display(node) + '</span>';
			}
			return ret;
		}});
		
		
		
		function textQuerySetup(query, limit, endpoint){
			var div = document.getElementById("textQueryDiv");
			div.addEventListener("click", function(){
				AJAXQuery(query + " LIMIT " + limit, endpoint, function(str){
					var msg = {text: str, query: query, limit: limit, endpoint: endpoint};
					for(var V of viewArray){
						V.processNotify(msg);
					}
				});
			});
		}
		
		
		
		
		//Contract: Query is a string. It is intended to be a SPARQL query, but that will be checked on the server. callback must be a function capable of taking a string argument. endpoint should be a URL to a SPARQL endpoint on which the query can be run. If the AJAX query terminates successfully, possibly after this function returns, callback() will be called on the response.
		function AJAXQuery(query, endpoint, callback){
			request = new XMLHttpRequest();
			request.open('POST', '/query', true);
			request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
			request.send('query='+query+'&endpoint='+endpoint);

			request.onreadystatechange = function(){
				//alert('readystate changed, status'+this.status.toString());
				if(this.readyState == 4 && this.status == 200){
					//alert('Response received:'+request.responseText);
					callback(request.responseText);
				}
			}

		}
		//this function is a hook for buttons and other HTML elements to access the view objects through their message bus.
		function trigger(identifier, msg){
			for (var view of viewArray){
				if (view.identifier == identifier)
				{
					view.processNotify(msg);
				}
			}
		}
		
		function objectTest(){
			var GV = new GraphView(viewArray, document.getElementById('graphFrame').contentWindow.document.getElementById('GraphDiv'));
			var LV = new ListView(viewArray, document.getElementById('listFrame').contentWindow.document.getElementById('ListDiv'));
			GV.JSONToGraph(JSONtestinput);
			var TV = new TreeView(viewArray, document.getElementById('treeDiv'), 7, function(n){if (n > 1) return [n-1,n-2]; else return [];}, function(n){return n.toString()}, function(n){alert("Number "+n.toString());});
			textQuerySetup("PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?X WHERE { <http://dbpedia.org/resource/Asturias> rdfs:label ?X }", 10, "http://dbpedia.org/sparql");
		}
	</script>
</head>


<body onload="objectTest()">

<div id="errorDiv"></div>
<div id="statusDiv"></div>
<div id="plainTextDiv"></div>
<div id="treeDiv"></div>
<div id="textQueryDiv">Click Here</div>
<iframe src="iframeDiv/ListView/ListDiv" id="listFrame" title="List View"
style="width:500px;height:500px;"></iframe>
<iframe src="iframeDiv/GraphView/GraphDiv" id="graphFrame" title="Graph View"
style="width:500px;height:500px;"></iframe>

<form>
	<label>Look up a Schema Diagram:</label>
	<input type="text" id="schemaAddress" style="width:500px;"></input>
</form>
</body>
</html>