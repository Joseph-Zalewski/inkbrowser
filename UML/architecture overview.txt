Here is a basic overview to try to extract classes from; rather than describing the use case, it will describe the architecture. Actually, use case first: the user is always someone who wants to query a sparql endpoint, containing some linked data file in RDF format (LDF). From the sdbrowser's point of view, this can be an arbitrary LDF, it need not even be an owl file. User actions: turn on web browser, navigate to ksu daselab domain, connect to server running sdbrowser by visiting its root url. This is the only url the user ever needs his browser to actually display as as HTML page; all other points of access on the server will be reached by AJAX requests. The user enters the URL of a sparql endpoint hosting the LDF he wants. Optionally he also enters the URL of its schema diagram spec. The schema diagram, either good-looking or bad-looking, appears on the page before him. It is clickable. When he clicks on a node, somehow the browser displays a whole bunch of nodes from the LDF which have that diagram node as class (or their rdf:type). It actually shows a whole bunch of triples starting with those nodes. This seems less than awesome to me; like you should get a list of the objects first, and be able to select them to see their triples, but whatever. And that's it. That's what it does.

Nouns: sparql endpoint, LDF, browser, point of view (irrelevant), owl file (irrelevant), web browser, domain, server, url, ajax request, schema diagram spec, schema diagram, page, node (in the diagram), bunch, node (from LDF), class (or rdf:type), triple, list.

Now, how is each of the above actions implemented, as far as you can guess? first thing it's involved in: connect to server running sdbrowser. There must be a static externally visible way to do this, thus a single entry-point url which is part of the contract and will never change. Perhaps "/main". I said this is the only page it need ever display, but that's limiting - it should be open for displaying more pages potentially, with extension of the code. Consider how a new page would be added, and if there is any need to change methods when you do so (OCP). Additional AJAX targets also need to be an option. Entering a URL: this will be an event-driven action: there will be a submit button which invokes a javascript function, which sends an AJAX request. The response is in some format, perhaps XML, and the javascript then creates the schema diagram from that. Displaying: This will be mxGraph invocations. Size will need to be autoscaled to the div. Further growth needs to be left available for size handling and so on. Clickable: mxGraph mxEvent.CLICK listener, which uses the cell property of the click event to identify its target. Display triples: the program should have the triples in some form, but the way they're output is specific. Simply dumping them in a DOM element might be okay. Problem: creating the schema diagram without the spec. There's a logic gate. Using the existing algorithm should suffice, the problem is where in the flow of execution the paths diverge. Is there one function which displays a diagram with a spec, which may or may not be generated? Or two functions, one with spec and one without?