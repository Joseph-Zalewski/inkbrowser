<!DOCTYPE html>
<html>
<title>Sdbrowser Client</title>
<!--This html contains the main client code for sdbrowser. It can:-->
<!--To Do:
	JSON decode - X?
	Add listeners - X
	Host this page from Flask - X
	Send queries to Python server - X
	Create View class - X
	Create graph view - X
	Create triple list view
	Create object list view
	Display query output
	Access hyperlinks in query output??
	Make paths to mxGraph source code platform-independent
	To Do on Flask End:
	Host a JSON file??
-->
<head>
	
	<script type="text/javascript">
		mxBasePath = {{url_for('static', filename='mxgraph/javascript/src')}};
	</script>
	
	<script type="text/javascript">
		JSONtestinput = '{ 	"Boxes":[ 		{"Id":"Source", 		"XOffset":100, 		"YOffset":100, 		"XSize":70, 		"YSize":30, 		"FillColorHex":"#ffffff", 		"TextColorHex":"#ff0000", 		"Label":"Source", "Query":"SELECT source FROM "}, 		 		{"Id":"Sink", 		"XOffset":200, 		"YOffset":300, 		"XSize":70, 		"YSize":30, 		"FillColorHex":"#ef99ef", 		"TextColorHex":"#ff0000", 		"Label":"Sink"} 	], 	"Arrows":[ 		{"Id":"Primary", 		"LabelX":200, 		"LabelY":200, 		"Label":"Primary", 		"ArrowType":"Hollow", 		"Source":"Source", 		"Target":"Sink", 		"Waypoints":[ 				[200,200], 				[220,200] 			] 		}, 		 		{"Id":"Segundo", 		"LabelX":200, 		"LabelY":200, 		"Label":"Secondary", 		"ArrowType":"Hollow", 		"Source":"Source", 		"Target":"Sink", 		"Waypoints":[ 				[400,200], 				[20,500], 				[30,750] 			], "AdditionalMxStyle":"endArrow=block;endFill=0;", "Query":"PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?label WHERE { <http://dbpedia.org/resource/Asturias> rdfs:label ?label }" 		} 	], 	"Mode":"DEFAULT", "CanvasX":500, "CanvasY":500 }';
	</script>
	
	<script type="text/javascript" src={{url_for('static', filename='mxgraph/javascript/mxClient.js')}}></script>
	
	<script type="text/javascript">
	
		////Class declarations
		//View class. Represents any user interface sdBrowser has. Since this is Javascript, subclasses can take an arbitrary additional parameters containing information such as the DOM node or DOM nodes it will use to display. However, it has one distinguished parameter, collection, which takes the view container it can notify. This class should be considered abstract and never instantiated except in a subclass constructor.
		function View(collection){
			this.collection = collection;
			collection.push(this);
		}
		View.prototype.processNotify = function(){};
		
		//GraphView subclass.
		function GraphView(collection, DOMNode){
			View.call(this, collection);
			this.DOMNode = DOMNode;
		}
		GraphView.prototype = Object.create(View.prototype);
		Object.defineProperty(GraphView.prototype, 'constructor', {value: GraphView, enumerable: false, writable: true,});
		Object.defineProperty(GraphView.prototype, 'JSONToGraph', {value: function(JSONString)
		{	
			JSONToGraph(JSONString, this.DOMNode);
		}});
		
		//PlainTextView subclass.
		function PlainTextView(collection, DOMNode){
			View.call(this, collection);
			this.DOMNode = DOMNode;
		}
		PlainTextView.prototype = Object.create(View.prototype);
		Object.defineProperty(PlainTextView.prototype, 'constructor', {value: PlainTextView, enumerable: false, writable: true,});
		PlainTextView.prototype.processNotify = function(str)
			{this.DOMNode.innerHTML = str;};
		
		function objectTest(){
			var viewArray = [];
			var GV = new GraphView(viewArray, document.getElementById('GraphDiv'));
			GV.JSONToGraph(JSONtestinput);
			var PTV = new PlainTextView(viewArray, document.getElementById('plainTextDiv'));
			PTV.processNotify('notification');
		}
	
		//Gets whatever is at the url.
		function getJSONSchema(url){
		
		};
		
		//Contract: e is an Arrow object extracted from a parsed internal JSON representation. Returns an mxEdgestyle which encodes the routing information for e, based on e.Waypoints, if that field is defined. Otherwise returns the default mxGraph elbow style.
		function constructEdgestyle(e){
			var style;
			if(e.Waypoints){
				style = function(state,source,target,points,result){
					for(var pt of e.Waypoints){
						result.push(new mxPoint(pt[0],pt[1]));
					}
				}
			}else{
				style = mxEdgeStyle.ElbowConnector;
			}
			return style;
		}
		
		//Contract: Query is a string. It is intended to be a SPARQL query, but that will be checked on the server. callback must be a function capable of taking a string argument. endpoint should be a URL to a SPARQL endpoint on which the query can be run. If the AJAX query terminates successfully, possibly after this function returns, callback() will be called on the response.
		function AJAXQuery(query, endpoint, callback){
			request = new XMLHttpRequest();
			request.open('POST', '/query', true);
			request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
			request.send('query='+query+'&endpoint='+endpoint);

			request.onreadystatechange = function(){
				alert('readystate changed, status'+this.status.toString());
				if(this.readyState == 4 && this.status == 200){
					alert('Response received:'+request.responseText);
					callback(request.responseText);
				}
			}

		}
		
		
		//Contract: String JSONString, DOM element pageElement.
		//Constructs the mxGraph encoded by JSONString, if there is one, in the DOM element pageElement.
		function JSONToGraph(JSONString, pageElement){
			var schema = JSON.parse(JSONString);
			if (!mxClient.isBrowserSupported())
			{
				mxUtils.error('Browser is not supported!', 200, false);
			}
			else{
				mxEvent.disableContextMenu(pageElement);
				var diagram = new mxGraph(pageElement);
				var parent = diagram.getDefaultParent();
				var nodes = {};
				var edges = {};
				diagram.getModel().beginUpdate();
				try{
					for(var b of schema.Boxes){
						nodes[b.Id] = diagram.insertVertex(parent, null, b.Id,b.XOffset,b.YOffset,b.XSize,b.YSize, 'fontColor='+b.TextColorHex+';fillColor='+b.FillColorHex+';'+b.AdditionalMxStyle);
					}
					
					for(var e of schema.Arrows){
						//create edgestyle for this edge
						mxEdgeStyle['sd'+e.Id] = constructEdgestyle(e);
						
						mxStyleRegistry.putValue('sd'+e.Id, mxEdgeStyle['sd'+e.Id]);
						//mxUtils.error(mxStyleRegistry.getValue('sd'+e.Id), 200, false);
						//insert the edge
						edges[e.Id] = diagram.insertEdge(parent, null, e.Label, nodes[e.Source], nodes[e.Target], 'edgeStyle=sd'+e.Id+';'+e.AdditionalMxStyle);
					}
					diagram.addListener(mxEvent.CLICK, function(sender, evt)
					{
						var e = evt.getProperty('event');
						var cell = evt.getProperty('cell');
						if(cell != null){
							for(b of schema.Boxes){
								if(nodes[b.Id] == cell){
									AJAXQuery(b.Query, 'http://dbpedia.org/sparql',
										function(str){
											document.getElementById('statusDiv').innerHTML = str;});
								}
							}
							for(e of schema.Arrows){
								if(edges[e.Id] == cell){
									AJAXQuery(e.Query, 'http://dbpedia.org/sparql',
										function(str){
											document.getElementById('statusDiv').innerHTML = str;});
								}
							}
						}
					});
				}
				catch(err){
					errorDiv.innerHTML = err.toString();
				}
				finally{
					diagram.getModel().endUpdate();
				}
			}
		};
	</script>
</head>
<!--<body onload="JSONToGraph(JSONtestinput, document.getElementById('graphDiv'))">-->
<body onload="objectTest()">

<div id="errorDiv"></div>
<div id="statusDiv"></div>
<div id="plainTextDiv"></div>
<div id="GraphDiv" style="position:relative;height:500px;width:500px;"></div>
</body>
</html>