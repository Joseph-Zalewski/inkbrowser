<!DOCTYPE html>
<html>
<title>Sdbrowser Client</title>
<!--This html contains the main client code for sdbrowser. It can:-->
<!--To Do:
	JSON decode - X?
	Add listeners - X
	Host this page from Flask - X
	Send queries to Python server
	Display query output
	Access hyperlinks in query output??
	Make paths to mxGraph source code platform-independent
	To Do on Flask End:
	Host a JSON file??
-->
<head>
	
	<script type="text/javascript">
		mxBasePath = {{url_for('static', filename='mxgraph/javascript/src')}};
	</script>
	
	<script type="text/javascript">
		JSONtestinput = '{ 	"Boxes":[ 		{"Id":"Source", 		"XOffset":100, 		"YOffset":100, 		"XSize":70, 		"YSize":30, 		"FillColorHex":"#ffffff", 		"TextColorHex":"#ff0000", 		"Label":"Source", "Query":"SELECT source FROM "}, 		 		{"Id":"Sink", 		"XOffset":200, 		"YOffset":300, 		"XSize":70, 		"YSize":30, 		"FillColorHex":"#ef99ef", 		"TextColorHex":"#ff0000", 		"Label":"Sink"} 	], 	"Arrows":[ 		{"Id":"Primary", 		"LabelX":200, 		"LabelY":200, 		"Label":"Primary", 		"ArrowType":"Hollow", 		"Source":"Source", 		"Target":"Sink", 		"Waypoints":[ 				[200,200], 				[220,200] 			] 		}, 		 		{"Id":"Segundo", 		"LabelX":200, 		"LabelY":200, 		"Label":"Secondary", 		"ArrowType":"Hollow", 		"Source":"Source", 		"Target":"Sink", 		"Waypoints":[ 				[400,200], 				[20,500], 				[30,750] 			], "AdditionalMxStyle":"endArrow=block;endFill=0;", "Query":"SELECT *" 		} 	], 	"Mode":"DEFAULT", "CanvasX":500, "CanvasY":500 }';
	</script>
	
	<script type="text/javascript" src={{url_for('static', filename='mxgraph/javascript/mxClient.js')}}></script>
	
	<script type="text/javascript">
		//Gets whatever is at the url.
		function getJSONSchema(url){
		
		};
		
		//Contract: e is an Arrow object extracted from a parsed internal JSON representation. Returns an mxEdgestyle which encodes the routing information for e, based on e.Waypoints, if that field is defined. Otherwise returns the default mxGraph elbow style.
		function constructEdgestyle(e){
			var style;
			if(e.Waypoints){
				style = function(state,source,target,points,result){
					for(var pt of e.Waypoints){
						result.push(new mxPoint(pt[0],pt[1]));
					}
				}
			}else{
				style = mxEdgeStyle.ElbowConnector;
			}
			return style;
		}
		
		//Contract: Query is a string. It is intended to be a SPARQL query, but that will be checked on the server. Return value is a JSON object containing query output, if the query was successful; otherwise, a failure value. endpoint should be a URL to a SPARQL endpoint on which the query can be run. If not, a failure value will be returned.
		function AJAXQuery(query, endpoint){
			request = new XMLHttpRequest();
			request.open('POST', '/query', true);
			request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
			request.send('query='+query+'&endpoint='+endpoint);
			request.onreadystatechange = function(){
				alert('readystate changed, status'+this.status.toString());
				if(this.readyState == 4 && this.status == 200){
					alert('Response received:'+request.responseText);
					var J = JSON.parse(request.responseText);
					alert('Response as JSON has head:'+J['head']);
				}
			}
		}
		
		AJAXQuery('PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> SELECT ?label WHERE { <http://dbpedia.org/resource/Asturias> rdfs:label ?label }', 'http://dbpedia.org/sparql');
		
		//Contract: String JSONString, DOM element pageElement.
		function JSONToGraph(JSONString, pageElement){
			var schema = JSON.parse(JSONString);
			if (!mxClient.isBrowserSupported())
			{
				mxUtils.error('Browser is not supported!', 200, false);
			}
			else{
				mxEvent.disableContextMenu(pageElement);
				var diagram = new mxGraph(pageElement);
				var parent = diagram.getDefaultParent();
				var nodes = {};
				var edges = {};
				diagram.getModel().beginUpdate();
				try{
					for(var b of schema.Boxes){
						nodes[b.Id] = diagram.insertVertex(parent, null, b.Id,b.XOffset,b.YOffset,b.XSize,b.YSize, 'fontColor='+b.TextColorHex+';fillColor='+b.FillColorHex+';'+b.AdditionalMxStyle);
					}
					
					for(var e of schema.Arrows){
						//create edgestyle for this edge
						mxEdgeStyle['sd'+e.Id] = constructEdgestyle(e);
						
						mxStyleRegistry.putValue('sd'+e.Id, mxEdgeStyle['sd'+e.Id]);
						mxUtils.error(mxStyleRegistry.getValue('sd'+e.Id), 200, false);
						//insert the edge
						edges[e.Id] = diagram.insertEdge(parent, null, e.Label, nodes[e.Source], nodes[e.Target], 'edgeStyle=sd'+e.Id+';'+e.AdditionalMxStyle);
					}
					diagram.addListener(mxEvent.CLICK, function(sender, evt)
					{
						var e = evt.getProperty('event');
						var cell = evt.getProperty('cell');
						if(cell != null){
							for(b of schema.Boxes){
								if(nodes[b.Id] == cell){
									statusDiv.innerHTML = b.Query;
								}
							}
							for(e of schema.Arrows){
								if(edges[e.Id] == cell){
									statusDiv.innerHTML = e.Query;
								}
							}
						}
					});
				}
				catch(err){
					errorDiv.innerHTML = err.toString();
				}
				finally{
					diagram.getModel().endUpdate();
				}
			}
		};
	</script>
</head>
<body onload="JSONToGraph(JSONtestinput, document.getElementById('graphDiv'))">
<div id="graphDiv" style="position:relative;height:500px;width:500px;"></div>
<div id="errorDiv"></div>
<div id="statusDiv"></div>
</body>
</html>